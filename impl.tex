\chapter{Implementation} % (fold)
\label{cha:impl}
	Just like in the previous chapter [\ref{cha:tasks}], every task will have its implementation process described in its own section.

	\section{Task 1} % (fold)
	\label{sec:impl_task_1}
		
	% section task_1 (end)

	\section{Task 2} % (fold)
	\label{sec:impl_task_2}
		Communication with the OLED display is to be facilitated by using an SPI master, which has to be added to the jConfig project. Connecting the SPI master instance to the required FPGA pins is straight forward as the required connections (CS, SCLK, SDIN, RES) are denoted by the the provided FPGA pin sheet. However, the displays' reset pin requires a separate output port instance to be generated by jConfig and can not be connected directly to the SPI paster peripheral. 

		\subsection{SPI Implementation} % (fold)
		\label{sub:impl_spi_implementation}
			Implementing the SPI driver is split into three parts:

			\begin{itemize}
				\item SPI enable and initial configuration
				\item SPI slave de-/select
				\item SPI data write
	   		\end{itemize}

	   		Each listed item will be described in one of the following paragraphs.

	   		\paragraph{Enable and Configuration} % (fold)
	   		\label{par:enable}
	   			Enabling and configuring the SPI master is implemented by writing to its control register. The task description states that the serial clock of the SPI connection has to be set to under \SI{10}{\mega\hertz}. This is achieved by setting the clock divider to two, resulting in a frequency of \SI{7.5}{\mega\hertz}. The bit width for each transfer is retrievable from the displays SPI manual and the fact that we will be using the described three wire interface, relying only on the serial data pin to send commands and data to the display. Reading further in the manual shows that eight bits plus one mode selection (command/data) bit are part of each transfer, making this nine bit in total. As a result of these observations, the value nine is written to the BITCNT property of the control register. Lastly, the enable bit is set, completing the initial configuration procedure.
	   		% paragraph enable (end)

	   		\paragraph{Slave De-/select} % (fold)
	   		\label{par:slave_de_select}
	   			Selecting the SPI slave targeted by the master requires a read to its control register. As the only available slave is attached to the first slave select signal, this value will be set one time before using the SPI interface and remains the same for the duration of the whole program.
	   		% paragraph slave_de_select (end)

	   		\paragraph{Data Write} % (fold)
	   		\label{par:data_write}
	   			As there is no need to retrieve data from to display, the write implementation will suffice to be able to use it. Writing to the masters data output register and waiting for all bits to be send is the only thing to do. This first (but also the final interrupt driven) implementation is polling the fill bits of the status register until the retrieved value is 0, denoting an empty output register and the ability to send more data.
	   			It is notable that the nine bits (one selecting command/data mode and eight actual with payload) to send are composed in such a way that the mode selection bit is the highest one.
	   		% paragraph data_write (end)
		% subsection impl_spi_implementation (end)

		\subsection{Display Driver Cleanup} % (fold)
		\label{sub:impl_display_driver_cleanup}
			As source code for the display driver is already provided, it remains to adjust it to our system. This includes the replacement of the data and command transaction routine implementations with own code calling the SPI procedures, but extends to the not compiling driver code. The latter is caused by multiple missing type declarations of local variables but also by the not defined global variable "Shift". Further errors are generated by the missing inclusion of the font header and by undefined GPIO related macros. As all GPIO accesses can be replaced by SPI or the newly introduced reset output port, no undefined variables and macros remain.

			\paragraph{ASCII Table} % (fold)
			\label{par:ascii_table}
				The recently mentioned font header provides data for printing ASCII characters to the display. However, when trying to write string literals to the display it can be observed that the provided table is shifted by an offset of minus 32. Simply adding this value to each index used in the Show\_Font57\_25664 procedure resolves this issue.
			% paragraph ascii_table (end)

			\paragraph{Global Shift} % (fold)
			\label{par:global_shift}
				%% TODO: see what the correct value is such that (0, 0) actually is (0, 0) on the display
				\textbf{TBD}
			% paragraph global_shift (end)
		% subsection display_driver_cleanup (end)

		\subsection{Display Usage} % (fold)
		\label{sub:display_usage}
			Before using the display it is required to configure the SPI master and initialise the display with the already available OLED\_Init\_25664 procedure. Afterwards, the displays' RAM is initialised to ensure a none noisy background.
			Printing strings to the display is achieved by a call to Show\_String\_25664. At this point it is possible to combine the sensor data retrieval with the display and solve the third task.
		% subsection display_usage (end)
	% section task_2 (end)

	\section{Task 3} % (fold)
	\label{sec:impl_task_3}
		\textbf{TBD}
		
		\subsection{Integer to String Conversion} % (fold)
		\label{sub:integer_to_string_conversion}
			\textbf{TBD}
		% subsection integer_to_string_conversion (end)

		\subsection{Integration} % (fold)
		\label{sub:integration}
			\textbf{TBD}
		% subsection integration (end)
	% section task_3 (end)

	\section{Bonus Task 1} % (fold)
	\label{sec:impl_bonus_task_1}
		Starting with initial thoughts on possible gains and costs for choosing SPI or I2C as the optimisation target, this section describes how the first bonus task was solved and which problems were encountered.

		\subsection{Initial Considerations} % (fold)
		\label{sub:initial_considerations}
			The first important question for solving this task is which components may profit from an interrupt driven operation. Both I2C and the SPI master interfaces are associated with waiting times when using them. 

			Updates of the display are limited to three bytes in size as measurements in cm will not produce results with more than three digits when considering the capabilities of the ultrasonic sensor. Furthermore, communication with the display (using the SPI interface) only has to occur when there is a change in the data to display. Busy waiting a small amount of cycles for these three bytes to be send seems to be preferable to the additional complexity introduced by implementing an interrupt based solution.
			All this shows that it is not worth while to change the display update procedures to be interrupt driven.

			Read and write transaction sizes for accessing the ultrasonic sensor are comparable to the display update sizes. On the other hand, considerable waiting time is associated with retrieving the measurement results. Using the fact that a reading the sensor through the I2C interface will only complete once its measurement process is finished, it is possible to implement a feasible interrupt based sensor write and read process which actually provides large performance benefits.
		% subsection initial_considerations (end)

		\subsection{Additional Hardware} % (fold)
		\label{sub:additional_hardware}
			Reading the SpartanMC manual provides basic information about the simple interrupt controller which is mandatory to be able to use interrupts in the SpartanMC context. Activating the interrupts on the I2C master and connecting its interrupt output port to the interrupt controller completes the peripheral side of the required hardware changes. Afterwards the interrupt signal of the controller is connected to the SpartanMC processor. At this point it remains to implement the interrupt service routine (ISR).
		% subsection additional_hardware (end)

		\subsection{Measurement FSM and Interrupt Handling} % (fold)
		\label{sub:measurement_fsm_and_interrupt_handling}
			To accommodate the different states of setting up a new measurement and retrieving the result, a simple state machine is required. We choose to implement state changes and state performed operations in the main loop to reduce the size and complexity of the ISR.
			...

			\paragraph{States and Transitions} % (fold)
			\label{par:states_and_transitions}
				% state and state changes
			% paragraph states_and_transitions (end)

			\paragraph{Causes for Interrupts} % (fold)
			\label{par:causes_for_interrupts}
				% failure and transactions completion
			% paragraph causes_for_interrupts (end)

			\paragraph{Required Workarounds} % (fold)
			\label{par:required_workarounds}
				% polling the sensor version and defeating the purpose of interrupts
			% paragraph required_workarounds (end)

			% - state changes initiated by boolean global
			% - boolean value switched when ISR is called
			% - check the new state of the code
		% subsection measurement_fsm_and_interrupt_handling (end)



	% section bonus_task_1 (end)

	\section{Bonus Task 2} % (fold)
	\label{sec:impl_bonus_task_2}
		% - use autoperf
		% - asm of sleep and sleep_sleep provides a good way to prove the execution characteristics 
	% section bonus_task_2 (end)
% chapter impl (end)